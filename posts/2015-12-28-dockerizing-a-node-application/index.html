<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Dockerizing a Node Application - bchoy.me</title><meta name=Description content="bchoy.me"><meta property="og:title" content="Dockerizing a Node Application">
<meta property="og:description" content="I&rsquo;ve been hearing good things about Docker ever since I started working professionally as a web developer. However, a lot of the deployment process was abstracted from me. The projects I worked on were mature and had an established workflow. The code I pushed up to Github will end up magically working on the staging server and then to production. A few weeks ago I was given the opportunity see a new project grow through its infancy. I saw a lot of problems with getting a project working locally to work on production. Something would break every few pushes and time would be wasted getting the devleopers and system administrators together to figure out a solution. After hearing so many good things about Docker and how it aims to solve the problems we were having in production, I suggested that we use Docker to develop our application and ship it to production.
Knowing absolutely nothing about Docker, these are the problems I faced and the references I used to figure out a workflow for our developers. This is yet another blog post where I jot down my thoughts and decision making, and not really walking through anything."><meta property="og:type" content="article"><meta property="og:url" content="https://bchoy.me/posts/2015-12-28-dockerizing-a-node-application/"><meta property="og:image" content="https://bchoy.me/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-12-28T16:32:20+00:00"><meta property="article:modified_time" content="2015-12-28T16:32:20+00:00"><meta property="og:site_name" content="bchoy.me"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bchoy.me/logo.png"><meta name=twitter:title content="Dockerizing a Node Application"><meta name=twitter:description content="I&rsquo;ve been hearing good things about Docker ever since I started working professionally as a web developer. However, a lot of the deployment process was abstracted from me. The projects I worked on were mature and had an established workflow. The code I pushed up to Github will end up magically working on the staging server and then to production. A few weeks ago I was given the opportunity see a new project grow through its infancy. I saw a lot of problems with getting a project working locally to work on production. Something would break every few pushes and time would be wasted getting the devleopers and system administrators together to figure out a solution. After hearing so many good things about Docker and how it aims to solve the problems we were having in production, I suggested that we use Docker to develop our application and ship it to production.
Knowing absolutely nothing about Docker, these are the problems I faced and the references I used to figure out a workflow for our developers. This is yet another blog post where I jot down my thoughts and decision making, and not really walking through anything."><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://bchoy.me/posts/2015-12-28-dockerizing-a-node-application/><link rel=prev href=https://bchoy.me/posts/2015-11-02-deploying-to-elastic-beanstalk-jenkins/><link rel=next href=https://bchoy.me/posts/2016-02-28-creating-a-docker-workflow-with-nodejs/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Dockerizing a Node Application","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/bchoy.me\/posts\/2015-12-28-dockerizing-a-node-application\/"},"genre":"posts","wordcount":1881,"url":"https:\/\/bchoy.me\/posts\/2015-12-28-dockerizing-a-node-application\/","datePublished":"2015-12-28T16:32:20+00:00","dateModified":"2015-12-28T16:32:20+00:00","license":"bchoy.me","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Brian Choy"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"light"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"light"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=bchoy.me>bchoy.me</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Blog </a><a class=menu-item href=/about>About </a><a class=menu-item href=/resume>Resume </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=bchoy.me>bchoy.me</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/posts/ title>Blog</a><a class=menu-item href=/about title>About</a><a class=menu-item href=/resume title>Resume</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class="toc-content always-active" id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Dockerizing a Node Application</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://bchoy.me title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Brian Choy</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=12-28-2015>12-28-2015</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;1881 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;9 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#why-use-docker>Why Use Docker?</a></li><li><a href=#should-i-use-vagrant>Should I Use Vagrant?</a></li><li><a href=#how-to-start-dockerizing>How to Start Dockerizing?</a></li><li><a href=#creating-a-dockerfile>Creating a Dockerfile</a></li><li><a href=#dockerignore>Dockerignore</a></li><li><a href=#building-the-container>Building the Container</a></li><li><a href=#troubleshooting-errors>Troubleshooting Errors</a></li><li><a href=#dealing-with-node_modules>Dealing with node_modules</a></li><li><a href=#ip-issues-across-the-local-machine-and-vm>IP Issues Across the Local Machine and VM</a></li><li><a href=#developing-in-docker>Developing in Docker</a></li></ul></nav></div></div><div class=content id=content><p>I&rsquo;ve been hearing good things about Docker ever since I started working professionally as a web developer. However, a lot of the deployment process was abstracted from me. The projects I worked on were mature and had an established workflow. The code I pushed up to Github will end up magically working on the staging server and then to production. A few weeks ago I was given the opportunity see a new project grow through its infancy. I saw a lot of problems with getting a project working locally to work on production. Something would break every few pushes and time would be wasted getting the devleopers and system administrators together to figure out a solution. After hearing so many good things about Docker and how it aims to solve the problems we were having in production, I suggested that we use Docker to develop our application and ship it to production.</p><p>Knowing absolutely nothing about Docker, these are the problems I faced and the references I used to figure out a workflow for our developers. This is yet another blog post where I jot down my thoughts and decision making, and not really walking through anything.</p><h2 id=why-use-docker>Why Use Docker?</h2><p>We all develop on OSX here at my company. The current project I&rsquo;m working on is a Node.js + React application that works perfectly fine on OSX, but encounters some issues with node_modules on production. Our Jenkins build will result in failure due to some unforeseen issue costing us time to troubleshoot and fix. Ideally we would work in an environment that mirrors production as close as possible to avoid these issues. Docker comes close to that ideal. Theoretically if our application works in a Docker container on our machines, it will also work the same in production.</p><h2 id=should-i-use-vagrant>Should I Use Vagrant?</h2><p>Vagrant supports Docker out of the box. During the beginning stages of my research, the blogs I were reading recommended using Docker with Vagrant. After setting up Docker with Vagrant, I decided that this was unnecessary for my current project. For a one container ecosystem in an all OSX dev environment, Vagrant adds additional complexity for no real gain. There was no real need to mimic the same exact environment across everyone&rsquo;s machines - our Dockerfile sufficed for this project. However, I ran into the problem of syncing files to actively develop using a running container. When an image is created, it is created with the current files and is not updated on further change. We want to sync our files to develop without rebuilding the container over and over. Vagrant helps solve this problem, but I found docker-osx-dev to be the best choice for this project. More reading on syncing local folders to a Docker container:</p><ul><li><a href=http://oliverguenther.de/2015/05/docker-host-volume-synchronization/ target=_blank rel="noopener noreffer">http://oliverguenther.de/2015/05/docker-host-volume-synchronization/</a></li><li><a href=https://hharnisc.github.io/2015/09/16/developing-inside-docker-containers-with-osx.html target=_blank rel="noopener noreffer">https://hharnisc.github.io/2015/09/16/developing-inside-docker-containers-with-osx.html</a></li></ul><p>More reading on Docker vs Vagrant:</p><ul><li><a href=https://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment target=_blank rel="noopener noreffer">https://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment</a></li><li><a href=http://www.ociweb.com/resources/publications/sett/march-2015-docker-vs-vagrant/ target=_blank rel="noopener noreffer">http://www.ociweb.com/resources/publications/sett/march-2015-docker-vs-vagrant/</a></li><li><a href=https://www.mikelangelo-project.eu/2015/10/5-steps-to-boost-your-productivity-with-vagrant-and-docker/ target=_blank rel="noopener noreffer">https://www.mikelangelo-project.eu/2015/10/5-steps-to-boost-your-productivity-with-vagrant-and-docker/</a></li><li><a href=http://activelamp.com/blog/devops/docker-with-vagrant/ target=_blank rel="noopener noreffer">http://activelamp.com/blog/devops/docker-with-vagrant/</a></li><li><a href=http://blog.scottlowe.org/2015/02/10/using-docker-with-vagrant/ target=_blank rel="noopener noreffer">http://blog.scottlowe.org/2015/02/10/using-docker-with-vagrant/</a></li></ul><h2 id=how-to-start-dockerizing>How to Start Dockerizing?</h2><p>How do I even start dockerizing this? It was a daunting task, but I was able to break it down over time and understand what I was doing. The first step was to install Docker via docker-machine. Docker runs natively on Linux - to run Docker on OSX, you will need <a href=https://www.virtualbox.org/wiki/Downloads target=_blank rel="noopener noreffer">Virtualbox</a> to run the docker-machine VM. If you run into blog posts talking about boot2docker, it has been replaced with docker-machine. boot2docker was a Linux distribution made specifically to run Docker containers. I&rsquo;m assuming docker-machine to be something similar.</p><p>Each shell you open, you will have to define which docker-machine VM you&rsquo;re using, else you&rsquo;ll run into the <code>Can't connect to docker daemon. Is 'docker -d' running on this host?</code> error. To avoid having to type <code>eval "$(docker-machine env default)"</code> over and over again in each shell I open, I just added it to my .bash_profile. This gives me access to all my docker commands. Some quick things you can type to get started:</p><ul><li>docker ps: Lists all your running containers</li><li>docker ps -a: Lists all containers that exist on your system</li><li>docker images: Lists all your images</li></ul><h2 id=creating-a-dockerfile>Creating a Dockerfile</h2><p>This is my Dockerfile for my Node.js project.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> ubuntu:14.04</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>MAINTAINER</span><span class=s> Brian Choy &lt;bchoy@barbariangroup.com&gt;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Install needed packages</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=o>&amp;&amp;</span> apt-get install -y <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      curl <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      build-essential <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      python <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>      zip<span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Install nvm</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh <span class=p>|</span> sh<span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Install node</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> cp -f ~/.nvm/nvm.sh ~/.nvm/nvm-tmp.sh<span class=p>;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=nb>echo</span> <span class=s2>&#34;nvm install 4.2.3; nvm alias default 4.2.3; ln -s ~/.nvm/versions/node/v4.2.3/bin/node /usr/bin/node; ln -s ~/.nvm/versions/node/v4.2.3/bin/npm /usr/bin/npm&#34;</span> &gt;&gt; ~/.nvm/nvm-tmp.sh<span class=p>;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    sh ~/.nvm/nvm-tmp.sh<span class=p>;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    rm ~/.nvm/nvm-tmp.sh<span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Install npm 3.5.1</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> npm install npm@3.5.1 -g<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Install dependencies with symlink to make work with volume mount</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> mkdir /app-dist <span class=o>&amp;&amp;</span> mkdir /app-dist/node_modules<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ADD</span> package.json /app-dist/package.json<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>cd</span> /app-dist <span class=o>&amp;&amp;</span> npm install<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> npm rebuild node-sass<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /src/app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ADD</span> . .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 3010</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;npm&#34;</span><span class=p>,</span> <span class=s2>&#34;run&#34;</span><span class=p>,</span> <span class=s2>&#34;dockerdev&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>Breakdown of an example Dockerfile: <a href=https://nodesource.com/blog/dockerizing-your-nodejs-applications/ target=_blank rel="noopener noreffer">https://nodesource.com/blog/dockerizing-your-nodejs-applications/</a></p><p>This Dockerfile tells Docker how to build out an image. With the Dockerfile, all images I create can be distributed and run locally or in production and be exactly the same. The comments I have in the Dockerfile pretty much explain what I&rsquo;m doing. The order of my tasks also matter due to the <a href=https://docs.docker.com/engine/articles/dockerfile_best-practices/ target=_blank rel="noopener noreffer">Docker build cache</a>. In a nutshell, each command is cached so that step does not have to be rebuilt unless changed. This significantly speeds up building an image by not recompiling things that are not changed. However this is not perfect and sometimes you will have to rebuild an image using the &ndash;no-cache flag. <code>ADD . .</code> is at the end because the directory we dev in has constantly changing files.</p><h2 id=dockerignore>Dockerignore</h2><p>.dockerignore:</p><pre tabindex=0><code class=language-git data-lang=git>log
tmp
.elasticbeanstalk/*
.git
.gitignore
node_modules/*
</code></pre><p>Just like .gitignore, I have files that I don&rsquo;t want compiled in my image. This file contains my AWS configs, node_modules, and my entire git history. Reducing bloat is always good - especially since the bandwidth used to pull images really adds up (more on Docker registries another time).</p><h2 id=building-the-container>Building the Container</h2><p>I built the container using the following command: <code>docker build -t page-creator .</code></p><p>This builds an image with the name page-creator while ignoring everything in the .dockerignore file. You can check the images you have on your system using <code>docker images</code>. Each build with the same name renames the older build to a blank name.</p><p>Older Docker images eats up your hard drive space over time. You can clear out all your blank names with <code>docker rmi $(docker images | grep \"^&lt;none>\" | awk \"{print $3}\")</code>. To abstract running these commands and bloating up the hard drive with old images, I changed my npm start task to run the following Docker commands: <code>"start": "docker kill node; docker rm node; docker rmi $(docker images | grep \"^&lt;none>\" | awk \"{print $3}\"); docker build -t page-builder .; docker run -it --name node -p 3000:3000 -p 3001:3001 -v $(pwd):/src/app --env-file=.env page-builder" npm run dev</code>.</p><p>I kill my container first because you cannot have two containers running with the same name. After that I remove it from my list of containers (that you can see with <code>docker ps -a</code>) and proceed to build a new image. Next I run the container with this command <code>docker run -d --name node -p 3000:3000 -p 3001:3001 -v $(pwd):/src/app --env-file=.env page-builder npm run dockerdev</code>
This runs the app in detached mode (-d) and the container is named node. -p routes my local 3000 port to the docker-machine&rsquo;s port 3000 and local 3000 to docker-machine 3000. -v mounts my present working directory onto the folder where my app is in the container. That way my files are synced in development. My env file is called .env and page-builder is the image I&rsquo;m running. <code>npm run dev</code> is a custom command I made and it is the command my docker container will use to run. If no command is specified, the command specified in my Dockerfile will be run.</p><h2 id=troubleshooting-errors>Troubleshooting Errors</h2><p>I could have saved so much time if I knew how to properly debug my containers early on. Since this was a single container ecosystem, debugging was quite simple to me. To ssh into a container that is running, I run <code>docker exec -it node bash</code>. &rsquo;node&rsquo; being the name of my container. This allows me to poke around a running instance. However if my instance crashed, the first thing I do is run <code>docker logs node</code> to see the output that caused my error. If I need to explore the filesystem, I create a snapshot of my container and run it with bash.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># find ID of your running container:</span>
</span></span><span class=line><span class=cl>docker ps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># create image (snapshot) from container filesystem</span>
</span></span><span class=line><span class=cl>docker commit 12345678904b5 mysnapshot
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># explore this filesystem using bash (for example)</span>
</span></span><span class=line><span class=cl>docker run -t -i mysnapshot /bin/bash
</span></span></code></pre></div><p><a href=https://stackoverflow.com/questions/20813486/exploring-docker-containers-file-system target=_blank rel="noopener noreffer">https://stackoverflow.com/questions/20813486/exploring-docker-containers-file-system</a></p><h2 id=dealing-with-node_modules>Dealing with node_modules</h2><p>The node_modules were a huge headache for me. Since I was mounting my pwd onto the container folder, my local node_modules were overwriting the ones in my application. Despite having the same version of node and npm on my local machine as the ones I&rsquo;m using in my container, my application does not run. A solution would be to delete my local node_modules folder and run npm install in my container, but it is incredibly inconvenient and time consuming to reinstall my node_modules each time I want to start developing. I solved this issue with a symlink. By deleting my local node_modules and creating a node_modules folder symlinked to /core-dist/node_modules, I now do not have a local node_modules folder that points to a real directory, but exists on my Docker container. The idea is to develop solely using the Docker container so the node_modules do not have to be functioning locally.
For reference: <a href=http://kevzettler.com/programming/2015/06/07/rapid_local_development_vagrant_docker_node.html target=_blank rel="noopener noreffer">http://kevzettler.com/programming/2015/06/07/rapid_local_development_vagrant_docker_node.html</a></p><h2 id=ip-issues-across-the-local-machine-and-vm>IP Issues Across the Local Machine and VM</h2><p>My app had a connection refused error on localhost:3000. This was an annoying one to fix because I haven&rsquo;t programmed much using Node.js and I spent a good aount of time figuring out if I was facing an issue with virtual machines or with Node.js. The answer is both. My issue was localhost is not the same on the virtual machine as it is on my actual physical machine. My local server did not work because webpackdevserver was operating on localhost and as I said before, localhost on the virtual machine is different from my physical machine&rsquo;s localhost. The simple fix that took me forever to figure out is to tell it to look at 0.0.0.0 instead of localhost.</p><figure><a class=lightgallery href=/posts/2015-12-28-dockerizing-a-node-application/images/connection-refused-fix.png title=/posts/2015-12-28-dockerizing-a-node-application/images/connection-refused-fix.png data-thumbnail=/posts/2015-12-28-dockerizing-a-node-application/images/connection-refused-fix.png data-sub-html="<h2>Connection Refused Fix</h2>"><img class=lazyload src=/svg/loading.min.svg data-src=/posts/2015-12-28-dockerizing-a-node-application/images/connection-refused-fix.png data-srcset="/posts/2015-12-28-dockerizing-a-node-application/images/connection-refused-fix.png, /posts/2015-12-28-dockerizing-a-node-application/images/connection-refused-fix.png 1.5x, /posts/2015-12-28-dockerizing-a-node-application/images/connection-refused-fix.png 2x" data-sizes=auto alt=/posts/2015-12-28-dockerizing-a-node-application/images/connection-refused-fix.png width=729 height=298></a><figcaption class=image-caption>Connection Refused Fix</figcaption></figure><h2 id=developing-in-docker>Developing in Docker</h2><p>Mounting my pwd does not continuously sync the files in the container. It just mounts once and creates the container. This is where Vagrant would have been a viable solution to have files synced in real time to my Docker container as I was developing. However, I found an even better solution <a href=https://stackoverflow.com/questions/30090007/whats-the-right-way-to-setup-a-development-environment-on-os-x-with-docker target=_blank rel="noopener noreffer">here</a>. <a href=https://github.com/brikis98/docker-osx-dev target=_blank rel="noopener noreffer">docker-osx-dev</a> is a GitHub repo that does all of those tasks for you and gives you the ability to sync your local files to docker-machine to your running containers. This way watch tasks and react hotloader work perfectly. My current workflow is to have docker-osx-dev running, rsyncing my files over to my container from my VM. If the install doesn&rsquo;t work, just run it again until it works (seriously). The errors seem to resolve themselves across the three machines I&rsquo;ve tested this on.</p><p>Setting up everything properly for staging and production comes next - <a href=http://www.ybrikman.com/writing/2015/11/11/running-docker-aws-ground-up/ target=_blank rel="noopener noreffer">http://www.ybrikman.com/writing/2015/11/11/running-docker-aws-ground-up/</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 12-28-2015</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/2015-11-02-deploying-to-elastic-beanstalk-jenkins/ class=prev rel=prev title="Deploying to Elastic Beanstalk on git push with Jenkins"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Deploying to Elastic Beanstalk on git push with Jenkins</a>
<a href=/posts/2016-02-28-creating-a-docker-workflow-with-nodejs/ class=next rel=next title="Creating a Docker Workflow with Node.js">Creating a Docker Workflow with Node.js<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2015 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://bchoy.me target=_blank>Brian Choy</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F9RPBWE7GE",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-F9RPBWE7GE" async></script></body></html>